# Boggle

The game begins by shaking a covered tray of 16 cubic dice, each with a different letter printed on each of its sides. The dice settle into a 4Ã—4 tray so that only the top letter of each cube is visible. After they have settled into the grid, a three-minute sand timer is started and all players simultaneously begin the main phase of play.[3]

Each player searches for words that can be constructed from the letters of sequentially adjacent cubes, where "adjacent" cubes are those horizontally, vertically, and diagonally neighboring. Words must be at least three letters long, may include singular and plural (or other derived forms) separately, but may not use the same letter cube more than once per word. Each player records all the words he or she finds by writing on a private sheet of paper. After three minutes have elapsed, all players must immediately stop writing and the game enters the scoring phase.

We have created a simple interface for a computer version of the game.  There is also a list of valid words that can be used to check if the words can contribute to the score.

https://en.wikipedia.org/wiki/Boggle

## The brief

We have created a number of acceptance tests for the Boggle Game and your challenge is to get them passing.  There is a simple game interface which is hooked into the test fixture.

## Some hints
ensure that your machine has visual studio (we used 2017 Cummunity Edition), and the following 2 extensions: 1) Nuget 2) 'specflow for visual studio 2017' (or appropriate). These can be installed under menu tools, Extensions and updates.	

The exercise contains an un-implemented Specflow BDD test (see http://www.specflow.org/getting-started/). The use of BDD in this instance is to provide you with our definition of done for the task.

Please ensure that you are familiar with our values in the instructions project.  They are important to us.

* simple, elegant code that reads like a narrative
* thinking about the code more than the writing of the code (we spend a lot of time thinking/debating about what we are writing)
* transparency and feedback to support continuous learning
* excellent unit testing that acts as documentation for the code
* challenging boundaries where necessary
